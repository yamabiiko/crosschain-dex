% TeX root = atomic-swaps.tex

\section{Decentralized exchange}

\paragraph*{Setting.} The system is composed by a set of liquidity providers $\mathcal{L}$ which deposit coins in so called \textit{liquidity pools}, where each pool $\mathcal{P}_i$ corresponds to assets from a different chain $\mathcal{B}_i$.  Clients $\mathcal{C}$ wanting to exchange tokens from a ledger $\mathbb{B}_a$ to another $\mathbb{B}_b$ can do so by initiating the protocol with the DEX system, transferring the assets $\mathsf{pk}_{\mathbb{B}_a}$ to the corresponding pool $\mathcal{P}_a$, and eventually receveing the corresponding assets from the matching pool $\mathcal{P}_b$ into their $\mathsf{pk}_{\mathbb{B}_b}$.

\paragraph*{Smart contract setup.}
In order to setup the protocol, the liquidity providers $\mathcal{L}$ run a pre-processing algorithm jointly executing a threshold signature scheme $\Pi.\mathsf{TDS}$ generate a jointly controlled public key pair $\mathsf{poolpk}_i$, $\mathsf{poolsk}_i$ for each chain $\mathbb{B}_i$.  
Finally, they all deposit as a collateral $\mathsf{amnt}$ to the smart-contract address $\mathsf{scpk}$ on chain $\mathcal{B}_sc$.
\paragraph*{Exchange}
\begin{enumerate}
	\item A client $\client$ intiliazes an exchange by sending the message $\msg_1 := (\tx^{\client \rightarrow \pool}_{\chain_a}, \pk_{\chain_b}, \pk_\client)$.
	\item If the transaction data in $\tx^{\client \rightarrow \pool}_{\chain_a}$ is accepted, the server proceeds to generate the unsigned transaction $\tx^{\pool \rightarrow \client}_{\chain_b})$ paying an amount relative to the swap request and the current exchange rate.
	\item The client verifies the respective validity of the amounts and targets of the transaction, and if accepted it proceeds to sign the tuple $\msg_2 := (\tx^{\client \rightarrow \pool}_{\chain_a}, \tx^{\pool \rightarrow \client}_{\chain_b}, \pk_{\chain_b}, \pk_\client)$, sending the signature $\sigma^{\msg_2}_{\client}$.
	\item The server verifies the tuple $\msg_2$ and the signature $\sigma^{\msg_2}_{\client}$, and similarly signs the tuple and sends the signature $\sigma^{\msg_2}_{\swappers}$.
	\item The server waits until $\tx^{\client \rightarrow \pool}_{\chain_a}$ is confirmed, and proceeds to respectively (threshold) sign and publish $\tx^{\pool \rightarrow \client}_{\chain_b}$, possibly exchanging the signature to the client.
\end{enumerate}
\paragraph*{Refund.} 
If the user does not receive a valid signature or detect the transaction, they can request a refund to the validation service, providing a transcript of the exchange messages. The validation service first verifies that all the messages have been signed by both the client $\client$ and the swappers $\swappers$, and that $\tx^{\client \rightarrow \pool}_{\chain_a}$ has been confirmed on $\chain_a$, and early aborts otherwise. It then proceeds to ask the swappers $\swappers$ to provide valid signature shares (or a full signature) on $\tx^{\pool \rightarrow \client}_{\chain_b}$. If the validation service can retrieve the signature, it forwards it to the user. Otherwise, it authorizes a refund using the staked assets of the detected cheating liquidity providers. \\
Because poolers might collude with a client if the exchange rate is not fair (i.e., by agreeing on sharing the profit), poolers that did not sign the transaction must be able to contest the transaction exchage rate to the smart contract and refund the difference.
\paragraph*{Withdrawal.}
Liquidity providers must be able to withdraw from each pool their originally deposited assets plus the fees that they earned.  \\
In order to withdraw their assets, poolers must be able to submit a withdrawal request to the network signed with their own key. They then create a transaction and request to threshold sign it, with other poolers aborting if the balance amount is incorrect. \\
In case other poolers want to collude to prevent a party from withdrawing their funds, a pooler can force a refund in a similar fashion as in the exchange step, that is by providing the transaction to the smart contract, which will proceed to trigger a request of signature shares for the transaction. (We should be careful to prevent double refunds).
In case other poolers want to collude with the withdrawer by signing a transaction where the balance is higher, the non-signing poolers should be able to trigger a refund / punishment from the staked balances.
\paragraph*{Collateral.}
Suppose the threshold signature requires $T$ signature shares out of $N$ parties. Then the minimum amount of collateral required to be staked in case of colluding poolers is $x \cdot \frac{N-T}{T}$, where $x$ is the amount of assets deposited for each secret key share.
The maximum amount a single user can swap with the whole swap covered by a collateral is $x \cdot T-1$.
\subsection{Syntax}
\begin{definition} The validation functionality $\smartcontract_{\mathsf{dex}}$ is defined by the following set of algorithms.
\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
    \item $\mathbf{0/1} \gets \mathbf{Setup}()$: Wait until all poolers have deposited the collateral $\amnt$
    \item $(\tx, \sigma) \gets \mathbf{ForceSwap}(T_\mathsf{swap}, \pk_{\chain_{\smartcontract}})$: The $\mathsf{ForceSwap}$ algorithm takes as input the transcript of the swap protocol $T_\mathsf{swap} = (\msg_1, \msg_2, ...)$ and a refund address $\pk_{\chain_{\smartcontract}}$. The algorithm verifies that each message in the transcript is correctly signed by the corresponding party, and that the transaction $\tx^{\client \rightarrow \pool}_{\chain_a}$ provided by the client $\client$ is confirmed, early aborting otherwise. It then proceeds to ask the participating set of liquidity providers $\swappers$ to provide the threshold signature shares for the transaction $\tx^{\pool \rightarrow \client}_{\chain_b}$. The algorithm then either outputs the complete signature $\sigma^{\pool \rightarrow \client}_{\chain_b}$ if it receives enough shares or issues a refund transaction to the provided refund address $\tx^{\smartcontract \rightarrow \client}_{\chain_\smartcontract}$, paying with the staked assets of the uncooperative liquidity providers and outputing it alongside its signature $\tx^{\smartcontract \rightarrow \client}_{\chain_\smartcontract}$
    \item $(\tx, \sigma) \gets \mathbf{Withdraw}(T_\mathsf{withdraw}, \pk_{\chain_{\smartcontract}})$:
    \item $(\tx, \sigma) \gets \mathbf{ForceWithdraw}(T_\mathsf{withdraw}, \pk_{\chain_{\smartcontract}})$: The $\mathsf{ForceWithdraw}$ algorithm takes as input the transcript of the withdrawal protocol $T_\mathsf{swap} = (\msg_1, \msg_2, ...)$ and a refund address $\pk_{\chain_{\smartcontract}}$. The algorithm verifies that each message in the transcript is correctly signed by the corresponding party. It then proceeds to ask the set of liquidity providers to provide a threshold signature on the withdraw transaction $\tx^{\pool \rightarrow \mathcal{L}}_{\chain_a}$.  The algorithm then either outputs the complete signature $\tx^{\pool \rightarrow \mathcal{L}}_{\chain_a}$ if it receives enough shares or issues a refund transaction to the provided refund address $\tx^{\smartcontract \rightarrow \mathcal{L}}_{\chain_\smartcontract}$, paying with the staked assets of the uncooperative liquidity providers and outputing it alongside its signature $\tx^{\smartcontract \rightarrow \mathcal{L}}_{\chain_\smartcontract}$
    \item $(0/1) \gets \mathbf{PunishWithdraw}(T_\mathsf{withdraw})$: The $\mathsf{PunishWithdraw}$ algorithm takes as input the transcript of the withdrawal protocol $T_\mathsf{withdraw} = (\msg_1, \msg_2, ...)$. 
    \item $(0/1) \gets \mathbf{PunishSwap}(T_\mathsf{swap})$: The $\mathsf{PunishSwap}$ algorithm takes as input the transcript of the withdrawal protocol $T_\mathsf{swap} = (\msg_1, \msg_2, ...)$.
\end{itemize}
\end{definition}

%\begin{itemize}
%	\item the message $\msg_1 := ( \pk_{\chain_a}, \pk_{\chain_b}, \amnt_a, \amnt_b, \pk_\client)$ along with the signatures $\sigma^{\msg_1}_\client$ and $\sigma^{(\msg_1, \sigma^{\msg_1}_\client)}_{\swappers}$ of the client and the pool, respectively.
%	\item the message $\msg_2 := ( \tx^{\client \rightarrow \pool}_{\chain_a}, \tx^{\pool \rightarrow \client}_{\chain_b} )$ and the signatures $\sigma^{\msg_2}_{\swappers}$, $\sigma^{\client \rightarrow \pool}_{\chain_a}$ on transaction $\tx^{\client \rightarrow \pool}$.
% 	\item a refund address $\pk_{\chain_{\smartcontract}}$
%\end{itemize}
\subsubsection{Building blocks.}
\paragraph*{Threshold signatures}
Transaction need to be authorized from a consensus of liquidity providers. Such a functionality can be achieved with the help of threshold signatures, described in section 3. Here we describe a protocol, run by a liquidity provider $\swappers_c$, acting as a "coordinator", together with all other liquidity providers.
\subsubsection{Transaction verification}
In order to avoid honesty assumption for liquidity providers or other parties, we must use realize a functionality that can be run as a smart contract (or realized as part of a ledger functionality) which can prove the confirmation of transaction for heterogeneous blockchains. \
We utilize the technique described in \cite{zkbridge} to validate transaction confirmation efficiently. We report the light client protocol and verification service.

\begin{definition}[Light client protocol]
A light client protocol enables a node to synchronize the block headers of the state of the
blockchain. Suppose all block headers in party $P$â€™s local view are $\{ \header_i \}^P_{i \in R}$, 
the light client protocol satisfies following properties:
\begin{enumerate}
	\item \textbf{Succinctness}: For each state update, the light client protocol only takes $O(1)$ time to synchronize the state.
	\item \textbf{Liveness}: If an honest full node receives some transaction $\mathsf{tx}$ at some round $i$, then $\mathsf{tx}$ must be included into the blockchain eventually. A light client protocol will eventually include a block header $\header_i$ such that the corresponding block includes the transaction $tx$.
        \item \textbf{Consistency}: as for any honest nodes $P_{\chaina}$ and $P{\chainb}$, and for any rounds of $R_0$ and $R_1$, it must be satisfied that either $\{ \header_i \}^{P_{\chaina}}_{i \in R_0}$ is a prefix of $\{ \header_i \}^{P{\chainb}}_{i \in R_1}$ or viceversa.
\end{enumerate}
\end{definition}


\begin{definition}[Verification service $\mathsf{VS}$]
A verification service $\mathsf{VS}_\chain$ parametired by the ledger $\chain$ is defined by the tuple of the following algorithms:
\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
    \item $(0,1) \gets$ \textbf{HeaderUpdate}$(\pi, \{ header_i \}_{i \in R})$: the $\mathsf{HeaderUpdate}$ stateful algorithm contains a list of verified headers $\mathcal{D}$ and a light client state $\mathsf{LCS}$. \\ The algorithm verifies that $\header_0 \in \mathcal{D}$ and $\mathsf{NIZK}.\mathsf{Vf}(\mathsf{LCS}, \pi, \{ header_i \}_{i \in R}) = 1$. If the verification succeeds, update $\mathsf{LCS}$ and $\mathcal{D}$ accordingly, returning 1. Otherwise, abort returning 0.
\end{itemize}
\end{definition}

In order to verify that a transaction has been included in a specific headers, it simply suffices to compute the Merkle proof of the transaction of such header. We generalize the notion using vector commitments.

\begin{itemize}
    \item $(\tx_1, ..., \tx_n) \gets \textbf{GetTxVec}(\st)$
\end{itemize}

\subsubsection{Contest service $\mathsf{CS}$}.

\begin{definition}[Contest service $\mathsf{CS}$]
A contest service $\mathsf{CS}_\smartcontract$ for some ledger $\smartcontract$ is defined by the tuple of the following algorithms:
\begin{itemize}[topsep=0pt, itemsep=0pt, leftmargin=2em]
    \item $(\tx, \sigma) \gets \mathbf{Contest}(T_\exc, \pi_\tx, n, \pk_\smartcontract)$: The $\contest$ algorithm takes as input the the transcript of the exchange protocol $T_\exc := (\exc, \sigma^\client_\exc, \sigma^\pool_\exc)$, where $\exc := (\tx_{\chaina}, \tx{\chainb}, \pk_c^\client)$. The algorithm does the following:
    \begin{itemize}
    \item It first verifies that both $\sigma^\client_\exc$ and $\sigma^\pool_\exc$ are valid signatures on the exchange message $\exc$, and aborts otherwise.
    \item It gets the root $C$ and transaction vector $(\tx_1, ..., \tx_n)$ from the $n$-th header from $\mathsf{VS}_{\chaina}$, and verifies that $\textbf{Verify}(C, n, \mathbf{tx}_n, \pi_\tx) = 1$, aborting otherwise.
    \item It now waits for each $\swappers_i$ that participated in the swap to provide a valid share of $\tx{\chainb}$. If it gets enough shares, it can output it to the user. Otherwise, record every uncooperative in $\mathcal{J} := \{ L_j \}_{j \in \swappers}$.
    \item If a valid signature could not be retrieved, punish the uncooperative liquidity providers in $\mathcal{J}$ by providing a refund to the user on $\pk_\smartcontract$
    \end{itemize}
\end{itemize}
\end{definition}
\subsubsection{Exchange protocol}
\begin{figure}[H]
    \begin{minipage}[t]{0.5\textwidth}
    \begin{pchstack}[boxed]
    %(\pk_{\chaina}^\pool, \pk_c^\pool, \pk^\pool{\chainb}, P, \sk_c^\user, \pk_c^\user, \sk_{\chaina}^\user, \pk^\user_{\chaina}, \sk^\user_{\chaina})
    \pseudocode{
        \text{Client $\client$}  \:\: \\[0.1\baselineskip ][\hline]
        \tx_{\chaina} := \mathsf{TxGen}_{\chaina}(\st, \pk_{\chaina}^\client, \pk_{\chaina}^\pool, \amnt_{\chaina}) \\
	\send(\coordinator, \tx_{\chaina}, \pk_c^\client) \\
	(\tx_{\chainb}, \rho) \gets \receive(\coordinator) \\
        \assert P(\tx_{\chaina}, \tx_{\chainb}) = 1 \\
        \exc := (\tx_{\chaina}, \tx_{\chainb}, \pk_c^\client, \rho) \\
        \sigma^\client_\exc := \Pi_c.\mathsf{Sg}(\sk_c^\client, \exc) \\
        \send(\swappers, \exc, \sigma_\exc) \\
	\sigma^{\coordinator}_\exc \gets \receive(\swappers_i) \\
        \assert \Sigma_c.\mathsf{Verify}(\pk_c^\pool, \exc, \sigma^\pool_\exc) \\
        \sigma^\client_{\tx_{\chaina}} := \Pi_{\chaina}.\mathsf{Sg}(\sk_{\chaina}^\client, \tx_{\chaina}) \\
        \mathsf{TxPub}_{\chaina}(\tx_{\chaina}, \sigma^\client_{\tx_{\chaina}}) \\
        \assert \mathsf{TxVf}_{\chainb}(\tx_{\chainb}) \neq 1 \\
    }
    \end{pchstack}
    \end{minipage}%
    \hspace{0.7cm}
    \begin{minipage}[t]{0.5\textwidth}
    \begin{pchstack}[boxed]
    \pseudocode{
	\text{Coordinator $\coordinator$} \:\: \\[0.1\baselineskip ][\hline]
        (\tx_{\chaina}, \pk_c^\client) \gets \receive(\client) \\
        \assert P(\tx_{\chaina}) = 1 \\
        \amnt_{\chainb} := \mathsf{Convert}(\chaina, \amnt_{\chaina}) \\
        \tx_{\chainb} := \mathsf{TxGen}_{\chainb}(st, \pk_{\chainb}^\pool, \pk_{\chainb}^\client, \amnt_{\chainb}) \\
	\send(\{ L_i \}_{i \in \swappers}, \tx_{\chainb}, \tx_{\chaina}, \pk_c^\client) \\
	\{ \rho_c^i, \rho_{\chainb}^i \}_{i \in \swappers} \gets \receive(\{ L_i \}_{i \in \swappers}) \\
	\rho_{\chainb} := \Sigma_{\chainb}.\mathsf{PreAgg}(\pk_b^\pool, \{ \rho_i \}_{i \in \swappers}) \\
	\send(\client, \tx_{\chainb}, \rho_{\chainb}) \\
        (\exc, \sigma_\exc) \gets \receive(\client) \\
        \assert \Pi_c.\mathsf{Vf}(\pk_c^\client, \exc, \sigma^\client_\exc) \\
	\send(\{ L_i \}_{i \in \swappers}, \exc, \pk_c^\client) \\
	\{ \sigma^i_{\exc} \}_{i \in \swappers} \gets \receive(\{ L_i \}_{i \in \swappers}) \\
	\sigma^\pool_\exc := \Sigma_c.\mathsf{SignAgg}(\pk_c^\pool, \{ \sigma^i_{\exc} \}_{i \in \swappers}, \exc) \\
        \send(\client, \sigma^\pool_\exc) \\
        \assert \mathsf{TxVf}_{\chaina}(\tx_{\chaina}) \\
	\{ \sigma^i_{\tx_{\chainb}} \}_{i \in \swappers} \gets \receive(\{ L_i \}_{i \in \swappers}) \\
	\sigma^\pool_{\tx_{\chainb}} := \Sigma_{\chainb}.\mathsf{SignAgg}(\pk_b^\pool, \{ \sigma^i_{\tx_{\chainb}} \}_{i \in \swappers}, \tx_{\chainb}) \\
        \mathsf{TxPub}_{\chainb}(\tx_{\chainb}, \sigma^\pool_{\tx_{\chainb}}) \\
    }
    \end{pchstack}
    \end{minipage}%
    \caption{Exchange protocol execution for a client $\client$ and a coordinator}
    \label{fig:dex_exchange}
\end{figure}
\begin{figure}[H]
    \begin{minipage}[t]{0.5\textwidth}
    \begin{pchstack}[boxed]
    \pseudocode{
        \text{Client $\client$}  \:\: \\[0.1\baselineskip ][\hline]
        \st_{\chaina} := \mathsf{GetState}_{\chaina} \\
        \header_l := \mathsf{VS}_{\chaina}.\mathsf{GetLastHeader} \\
        \{ \header \}_{l,..,n} := \parse \st_{\chaina} \\
        \mathsf{wit} := \mathsf{LCS}_l \\
        \mathsf{stmnt} :=  \{ \header \}_{l,..,n} \\
        \pi := \mathsf{NIZK}.\mathsf{Prove}(\mathsf{wit}, \mathsf{stmnt}) \\
        \mathsf{VS}_{\chaina}.\mathsf{HeaderUpdate}(\pi, \{ \header \}_{l,..,n}) \\
	(\tx_1, ..., \tx_l) \gets \textsf{GetTxVec}(n, \st_{\chaina}) \\
        I := \{ I \in \{ 1,..,n \} \mid \mathsf{tx}_I = \tx_{\chaina} \} \\
        \pi_\tx := \mathsf{VC}.\mathsf{Open}((\mathsf{tx}_1, ..., \mathsf{tx}_l), I) \\
        T_\exc := (\exc, \sigma^\client_\exc, \sigma^\pool_\exc) \\
        \mathsf{RS}.\contest(T_\exc, \pi_\tx, n, \pk_\smartcontract) \\
    }
    \end{pchstack}
    \end{minipage}%
    \caption{Contest protocol execution for a client $\client$}
    \label{fig:dex_refund}
\end{figure}

\subsection{Correctness}
\subsection{Security}
\subsection{Construction}

\newpage
